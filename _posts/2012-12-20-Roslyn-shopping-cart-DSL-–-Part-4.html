---           
layout: post
title: Roslyn shopping cart DSL – Part 4
date: 2012-12-20 01:52:26 UTC
updated: 2012-12-20 01:52:26 UTC
comments: false
categories: DSL Roslyn
---
<br /><div class="MsoNormal"><span lang="EN-US"><b>Why Source to source translation?</b><o:p></o:p></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal">In order to answer that question, I wanna provide some background on what are the choices that we have when building a DSL on .NET (at least the most common that I’ve used).</div><div class="MsoNormal"><span lang="EN-US"><br /></span></div><div class="MsoNormal"><span lang="EN-US">Prior to the “magic lambda” era, there were few choices, the one I've used the most, was a hand written parser that creates syntax trees and a code generator that traverses those trees generating MSIL code using Reflection.Emit. This solution was OK but it was also a lot of work, even for a simple "Hello World DSL". It’s definitely a path I wouldn't take nowadays.<o:p></o:p></span></div><div class="MsoNormal"><span lang="EN-US"><br /></span></div><div class="MsoNormal">When .NET 3.5 saw the light, we had more options, back then it was possible to use linq expressions to represent our programs and traverse those expressions in order to emit target code. It wasn’t &nbsp;the easyest thing, but at least the days were we have to build a bunch of classes to represent or compose expressions were gone. Then we had the lambda compiler and linq statements which allowed us to compose and compile more complex lambdas to delegates and invoke those delegates just as normal code.</div><div class="MsoNormal"><br /></div><div class="MsoNormal">Along the way (between 2.0 and 3.5) the DLR was born and gave us a net way to work with call sites, dynamic types, runtime binders, and so on. We still had to write our own parsers, but the rest of what we need was ready to use. And also we could peek at the IronPython code, IronRuby and the DLR itself and see how things work under the hood.</div><div class="MsoNormal"><span lang="EN-US"><br /></span></div><div class="MsoNormal"><span lang="EN-US">And finally we got Roslyn which give us a whole bunch of magic right out of the box as long as we provide valid C# or VB code, and this is why I choose source to source translation. It's way easier to implement than any of the options mentioned above, because almost all of the components are already built, this allow us to build a walking skeleton in a couple of hours or a maybe one or two days.<o:p></o:p></span></div><div class="MsoNormal"><span lang="EN-US"><br /></span></div><div class="MsoNormal"><span lang="EN-US">There’s a couple of ways to do source to source translation, usually the choice relies on the DSL's syntax complexity (which should remain simple for our DSL to succeed). In this post I took the "the simplest code that maybe works"&nbsp;</span>approach&nbsp;, which was string substitution. The end result was a piece of sloppy code, that you may never want to use in a real app, but it was good enough to get the job done ;)</div><div class="MsoNormal"><span lang="EN-US"><br /></span></div><div class="MsoNormal"><span lang="EN-US"></span></div><div class="MsoNormal">In future posts I’ll be showing how to implement source to source translation for non trivial scenarios. I’ll try to include how to parse source code, build syntax trees and traverse those trees emitting target language code.</div><div class="MsoNormal"><br /></div><div class="MsoNormal">There is a bunch of aspects I didn’t cover in this series such as error handling, performance, code optimizations, parser generators and so on and so forth, but I think was a good starting point to start playing with DSLs on top of the Roslyn APIs.</div><br /><div class="MsoNormal"><span lang="EN-US"><br /></span></div>